
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsH.js
 */
#pragma once

#include <react/renderer/components/view/ViewProps.h>
#include <react/renderer/core/PropsParserContext.h>
#include <react/renderer/core/propsConversions.h>
#include <vector>

namespace facebook::react {

enum class CameraViewPixelFormat { Yuv, Rgb };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, CameraViewPixelFormat &result) {
  auto string = (std::string)value;
  if (string == "yuv") { result = CameraViewPixelFormat::Yuv; return; }
  if (string == "rgb") { result = CameraViewPixelFormat::Rgb; return; }
  abort();
}

static inline std::string toString(const CameraViewPixelFormat &value) {
  switch (value) {
    case CameraViewPixelFormat::Yuv: return "yuv";
    case CameraViewPixelFormat::Rgb: return "rgb";
  }
}
enum class CameraViewTorch { Off, On };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, CameraViewTorch &result) {
  auto string = (std::string)value;
  if (string == "off") { result = CameraViewTorch::Off; return; }
  if (string == "on") { result = CameraViewTorch::On; return; }
  abort();
}

static inline std::string toString(const CameraViewTorch &value) {
  switch (value) {
    case CameraViewTorch::Off: return "off";
    case CameraViewTorch::On: return "on";
  }
}
enum class CameraViewResizeMode { Cover, Contain };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, CameraViewResizeMode &result) {
  auto string = (std::string)value;
  if (string == "cover") { result = CameraViewResizeMode::Cover; return; }
  if (string == "contain") { result = CameraViewResizeMode::Contain; return; }
  abort();
}

static inline std::string toString(const CameraViewResizeMode &value) {
  switch (value) {
    case CameraViewResizeMode::Cover: return "cover";
    case CameraViewResizeMode::Contain: return "contain";
  }
}
enum class CameraViewAndroidPreviewViewType { SurfaceView, TextureView };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, CameraViewAndroidPreviewViewType &result) {
  auto string = (std::string)value;
  if (string == "surface-view") { result = CameraViewAndroidPreviewViewType::SurfaceView; return; }
  if (string == "texture-view") { result = CameraViewAndroidPreviewViewType::TextureView; return; }
  abort();
}

static inline std::string toString(const CameraViewAndroidPreviewViewType &value) {
  switch (value) {
    case CameraViewAndroidPreviewViewType::SurfaceView: return "surface-view";
    case CameraViewAndroidPreviewViewType::TextureView: return "texture-view";
  }
}
enum class CameraViewPhotoQualityBalance { Speed, Balanced, Quality };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, CameraViewPhotoQualityBalance &result) {
  auto string = (std::string)value;
  if (string == "speed") { result = CameraViewPhotoQualityBalance::Speed; return; }
  if (string == "balanced") { result = CameraViewPhotoQualityBalance::Balanced; return; }
  if (string == "quality") { result = CameraViewPhotoQualityBalance::Quality; return; }
  abort();
}

static inline std::string toString(const CameraViewPhotoQualityBalance &value) {
  switch (value) {
    case CameraViewPhotoQualityBalance::Speed: return "speed";
    case CameraViewPhotoQualityBalance::Balanced: return "balanced";
    case CameraViewPhotoQualityBalance::Quality: return "quality";
  }
}
enum class CameraViewVideoStabilizationMode { Off, Standard, Cinematic, CinematicExtended, Auto };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, CameraViewVideoStabilizationMode &result) {
  auto string = (std::string)value;
  if (string == "off") { result = CameraViewVideoStabilizationMode::Off; return; }
  if (string == "standard") { result = CameraViewVideoStabilizationMode::Standard; return; }
  if (string == "cinematic") { result = CameraViewVideoStabilizationMode::Cinematic; return; }
  if (string == "cinematic-extended") { result = CameraViewVideoStabilizationMode::CinematicExtended; return; }
  if (string == "auto") { result = CameraViewVideoStabilizationMode::Auto; return; }
  abort();
}

static inline std::string toString(const CameraViewVideoStabilizationMode &value) {
  switch (value) {
    case CameraViewVideoStabilizationMode::Off: return "off";
    case CameraViewVideoStabilizationMode::Standard: return "standard";
    case CameraViewVideoStabilizationMode::Cinematic: return "cinematic";
    case CameraViewVideoStabilizationMode::CinematicExtended: return "cinematic-extended";
    case CameraViewVideoStabilizationMode::Auto: return "auto";
  }
}
enum class CameraViewOutputOrientation { Device, Preview };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, CameraViewOutputOrientation &result) {
  auto string = (std::string)value;
  if (string == "device") { result = CameraViewOutputOrientation::Device; return; }
  if (string == "preview") { result = CameraViewOutputOrientation::Preview; return; }
  abort();
}

static inline std::string toString(const CameraViewOutputOrientation &value) {
  switch (value) {
    case CameraViewOutputOrientation::Device: return "device";
    case CameraViewOutputOrientation::Preview: return "preview";
  }
}
struct CameraViewFormatStruct {
  double photoHeight{0.0};
  double photoWidth{0.0};
  double videoHeight{0.0};
  double videoWidth{0.0};
  double maxISO{0.0};
  double minISO{0.0};
  double fieldOfView{0.0};
  bool supportsVideoHdr{false};
  bool supportsPhotoHdr{false};
  bool supportsDepthCapture{false};
  double minFps{0.0};
  double maxFps{0.0};
  std::string autoFocusSystem{};
  std::vector<std::string> videoStabilizationModes{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, CameraViewFormatStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_photoHeight = map.find("photoHeight");
  if (tmp_photoHeight != map.end()) {
    fromRawValue(context, tmp_photoHeight->second, result.photoHeight);
  }
  auto tmp_photoWidth = map.find("photoWidth");
  if (tmp_photoWidth != map.end()) {
    fromRawValue(context, tmp_photoWidth->second, result.photoWidth);
  }
  auto tmp_videoHeight = map.find("videoHeight");
  if (tmp_videoHeight != map.end()) {
    fromRawValue(context, tmp_videoHeight->second, result.videoHeight);
  }
  auto tmp_videoWidth = map.find("videoWidth");
  if (tmp_videoWidth != map.end()) {
    fromRawValue(context, tmp_videoWidth->second, result.videoWidth);
  }
  auto tmp_maxISO = map.find("maxISO");
  if (tmp_maxISO != map.end()) {
    fromRawValue(context, tmp_maxISO->second, result.maxISO);
  }
  auto tmp_minISO = map.find("minISO");
  if (tmp_minISO != map.end()) {
    fromRawValue(context, tmp_minISO->second, result.minISO);
  }
  auto tmp_fieldOfView = map.find("fieldOfView");
  if (tmp_fieldOfView != map.end()) {
    fromRawValue(context, tmp_fieldOfView->second, result.fieldOfView);
  }
  auto tmp_supportsVideoHdr = map.find("supportsVideoHdr");
  if (tmp_supportsVideoHdr != map.end()) {
    fromRawValue(context, tmp_supportsVideoHdr->second, result.supportsVideoHdr);
  }
  auto tmp_supportsPhotoHdr = map.find("supportsPhotoHdr");
  if (tmp_supportsPhotoHdr != map.end()) {
    fromRawValue(context, tmp_supportsPhotoHdr->second, result.supportsPhotoHdr);
  }
  auto tmp_supportsDepthCapture = map.find("supportsDepthCapture");
  if (tmp_supportsDepthCapture != map.end()) {
    fromRawValue(context, tmp_supportsDepthCapture->second, result.supportsDepthCapture);
  }
  auto tmp_minFps = map.find("minFps");
  if (tmp_minFps != map.end()) {
    fromRawValue(context, tmp_minFps->second, result.minFps);
  }
  auto tmp_maxFps = map.find("maxFps");
  if (tmp_maxFps != map.end()) {
    fromRawValue(context, tmp_maxFps->second, result.maxFps);
  }
  auto tmp_autoFocusSystem = map.find("autoFocusSystem");
  if (tmp_autoFocusSystem != map.end()) {
    fromRawValue(context, tmp_autoFocusSystem->second, result.autoFocusSystem);
  }
  auto tmp_videoStabilizationModes = map.find("videoStabilizationModes");
  if (tmp_videoStabilizationModes != map.end()) {
    fromRawValue(context, tmp_videoStabilizationModes->second, result.videoStabilizationModes);
  }
}

static inline std::string toString(const CameraViewFormatStruct &value) {
  return "[Object CameraViewFormatStruct]";
}

struct CameraViewCodeScannerOptionsRegionOfInterestStruct {
  double x{0.0};
  double y{0.0};
  double width{0.0};
  double height{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, CameraViewCodeScannerOptionsRegionOfInterestStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_x = map.find("x");
  if (tmp_x != map.end()) {
    fromRawValue(context, tmp_x->second, result.x);
  }
  auto tmp_y = map.find("y");
  if (tmp_y != map.end()) {
    fromRawValue(context, tmp_y->second, result.y);
  }
  auto tmp_width = map.find("width");
  if (tmp_width != map.end()) {
    fromRawValue(context, tmp_width->second, result.width);
  }
  auto tmp_height = map.find("height");
  if (tmp_height != map.end()) {
    fromRawValue(context, tmp_height->second, result.height);
  }
}

static inline std::string toString(const CameraViewCodeScannerOptionsRegionOfInterestStruct &value) {
  return "[Object CameraViewCodeScannerOptionsRegionOfInterestStruct]";
}

struct CameraViewCodeScannerOptionsStruct {
  std::vector<std::string> codeTypes{};
  CameraViewCodeScannerOptionsRegionOfInterestStruct regionOfInterest{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, CameraViewCodeScannerOptionsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_codeTypes = map.find("codeTypes");
  if (tmp_codeTypes != map.end()) {
    fromRawValue(context, tmp_codeTypes->second, result.codeTypes);
  }
  auto tmp_regionOfInterest = map.find("regionOfInterest");
  if (tmp_regionOfInterest != map.end()) {
    fromRawValue(context, tmp_regionOfInterest->second, result.regionOfInterest);
  }
}

static inline std::string toString(const CameraViewCodeScannerOptionsStruct &value) {
  return "[Object CameraViewCodeScannerOptionsStruct]";
}
class CameraViewProps final : public ViewProps {
 public:
  CameraViewProps() = default;
  CameraViewProps(const PropsParserContext& context, const CameraViewProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  bool isActive{false};
  bool preview{false};
  bool photo{false};
  bool video{false};
  bool audio{false};
  CameraViewPixelFormat pixelFormat{CameraViewPixelFormat::Yuv};
  bool enableLocation{false};
  CameraViewTorch torch{CameraViewTorch::Off};
  double zoom{0.0};
  bool enableZoomGesture{false};
  double exposure{0.0};
  CameraViewFormatStruct format{};
  CameraViewResizeMode resizeMode{CameraViewResizeMode::Cover};
  CameraViewAndroidPreviewViewType androidPreviewViewType{CameraViewAndroidPreviewViewType::SurfaceView};
  bool videoHdr{false};
  bool photoHdr{false};
  CameraViewPhotoQualityBalance photoQualityBalance{CameraViewPhotoQualityBalance::Balanced};
  bool enableBufferCompression{false};
  bool lowLightBoost{false};
  CameraViewVideoStabilizationMode videoStabilizationMode{CameraViewVideoStabilizationMode::Off};
  bool enableDepthData{false};
  bool enablePortraitEffectsMatteDelivery{false};
  CameraViewOutputOrientation outputOrientation{CameraViewOutputOrientation::Device};
  bool isMirrored{false};
  std::string cameraId{};
  bool enableFrameProcessor{false};
  CameraViewCodeScannerOptionsStruct codeScannerOptions{};
  double minFps{0.0};
  double maxFps{0.0};
};

} // namespace facebook::react
